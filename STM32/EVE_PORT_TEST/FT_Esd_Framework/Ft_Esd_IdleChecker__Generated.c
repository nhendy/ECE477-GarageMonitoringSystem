/*
This file is automatically generated
DO NOT MODIFY BY HAND
Ft_Esd_IdleChecker
C Source
*/

#include "Ft_Esd_IdleChecker.h"

#include "Ft_Esd_Math.h"
#include "Ft_Esd_TouchTag.h"

extern void Ft_Esd_Noop(void *context);
int Ft_Esd_IdleChecker_X__Default(void *context) { return 0L; }
int Ft_Esd_IdleChecker_Y__Default(void *context) { return 0L; }
int Ft_Esd_IdleChecker_Width__Default(void *context) { return 800L; }
int Ft_Esd_IdleChecker_Height__Default(void *context) { return 800L; }
int Ft_Esd_IdleChecker_Count__Default(void *context) { return 30L; }
int Ft_Esd_IdleChecker_Interval__Default(void *context) { return 1000L; }

static int Ft_Esd_IdleChecker_Touch_Area_X__Property(void *context);
static int Ft_Esd_IdleChecker_Touch_Area_Y__Property(void *context);
static int Ft_Esd_IdleChecker_Touch_Area_Width__Property(void *context);
static int Ft_Esd_IdleChecker_Touch_Area_Height__Property(void *context);

static void Ft_Esd_IdleChecker_ESD_Timer_Fired__Signal(void *context);
static void Ft_Esd_IdleChecker_Touch_Area_Up__Signal(void *context);
static void Ft_Esd_IdleChecker_Touch_Area_Down__Signal(void *context);

void Ft_Esd_IdleChecker__ESD_Timer__Initializer(Ft_Esd_IdleChecker *context)
{
	Ft_Esd_Timer *object = &context->ESD_Timer;
	Ft_Esd_Timer__Initializer(object);
	object->Owner = context;
	object->Repeat = 1;
	object->Fired = Ft_Esd_IdleChecker_ESD_Timer_Fired__Signal;
}

void Ft_Esd_IdleChecker__Touch_Area__Initializer(Ft_Esd_IdleChecker *context)
{
	Ft_Esd_TouchArea *object = &context->Touch_Area;
	Ft_Esd_TouchArea__Initializer(object);
	object->Owner = context;
	object->X = Ft_Esd_IdleChecker_Touch_Area_X__Property;
	object->Y = Ft_Esd_IdleChecker_Touch_Area_Y__Property;
	object->Width = Ft_Esd_IdleChecker_Touch_Area_Width__Property;
	object->Height = Ft_Esd_IdleChecker_Touch_Area_Height__Property;
	object->Up = Ft_Esd_IdleChecker_Touch_Area_Up__Signal;
	object->Down = Ft_Esd_IdleChecker_Touch_Area_Down__Signal;
}

void Ft_Esd_IdleChecker__Initializer(Ft_Esd_IdleChecker *context)
{
	context->Owner = 0;
	context->X = Ft_Esd_IdleChecker_X__Default;
	context->Y = Ft_Esd_IdleChecker_Y__Default;
	context->PreviousStatus = 0;
	context->Width = Ft_Esd_IdleChecker_Width__Default;
	context->IdleTime = 0L;
	context->Height = Ft_Esd_IdleChecker_Height__Default;
	context->Status = 0;
	context->Count = Ft_Esd_IdleChecker_Count__Default;
	context->TimeLimit = 0L;
	context->Interval = Ft_Esd_IdleChecker_Interval__Default;
	context->Timeout = Ft_Esd_Noop;
	context->Deferred_Wakeup = 0;
	context->WakeUp = Ft_Esd_Noop;
	Ft_Esd_IdleChecker__ESD_Timer__Initializer(context);
	Ft_Esd_IdleChecker__Touch_Area__Initializer(context);
}

ft_uint8_t Ft_Esd_TouchTag_CurrentTag(Ft_Esd_TouchTag *);

void Ft_Esd_IdleChecker_Update__Builtin(Ft_Esd_IdleChecker *context)
{
	void *owner = context->Owner;
	int update_variable = context->Count(owner);
	context->TimeLimit = update_variable;
	int update_variable_1 = context->Interval(owner);
	context->ESD_Timer.TimeoutMs = update_variable_1;
	Ft_Esd_TouchArea_Update(&context->Touch_Area);
}

void Ft_Esd_IdleChecker_End(Ft_Esd_IdleChecker *context)
{
	void *owner = context->Owner;
	Ft_Esd_Timer_End(&context->ESD_Timer);
}

void Ft_Esd_IdleChecker_Start(Ft_Esd_IdleChecker *context)
{
	void *owner = context->Owner;
	Ft_Esd_Timer_Run(&context->ESD_Timer);
}

void Ft_Esd_IdleChecker_Update(Ft_Esd_IdleChecker *context)
{
	void *owner = context->Owner;
	Ft_Esd_TouchTag * context_1 = 0x0;
	ft_uint8_t left = Ft_Esd_TouchTag_CurrentTag(context_1);
	int right = 0L;
	int if_1 = left != right;
	if (if_1)
	{
		int clear = 0L;
		context->IdleTime = clear;
		ft_bool_t if_2 = context->Touch_Area.Touching;
		if (if_2)
		{
		}
		else
		{
			int left_1 = context->IdleTime;
			int right_1 = 1L;
			int value = left_1 + right_1;
			ft_int32_t min = 0L;
			int max = context->TimeLimit;
			ft_int32_t set_increase = Ft_Esd_Int32_ClampedValue(value, min, max);
			context->IdleTime = set_increase;
		}
		ft_bool_t copy_status = context->Status;
		context->PreviousStatus = copy_status;
		int left_2 = context->IdleTime;
		int right_2 = context->TimeLimit;
		int if_3 = left_2 == right_2;
		if (if_3)
		{
			ft_bool_t set_timeout_status = 1;
			context->Status = set_timeout_status;
		}
		else
		{
			ft_bool_t clear_timeout_status = 0;
			context->Status = clear_timeout_status;
		}
		ft_bool_t left_3 = context->PreviousStatus;
		ft_bool_t right_3 = 1;
		int if_4 = left_3 == right_3;
		if (if_4)
		{
			ft_bool_t left_4 = context->Status;
			ft_bool_t right_4 = 0;
			int if_5 = left_4 == right_4;
			if (if_5)
			{
				ft_bool_t set_deferred_wakeup = 1;
				context->Deferred_Wakeup = set_deferred_wakeup;
			}
			else
			{
			}
		}
		else
		{
			ft_bool_t left_5 = context->Status;
			ft_bool_t right_5 = 1;
			int if_6 = left_5 == right_5;
			if (if_6)
			{
				context->Timeout(owner);
			}
			else
			{
			}
		}
	}
	else
	{
		ft_bool_t if_7 = context->Deferred_Wakeup;
		if (if_7)
		{
			context->WakeUp(owner);
			ft_bool_t clear_deferred_wakeup = 0;
			context->Deferred_Wakeup = clear_deferred_wakeup;
		}
		else
		{
		}
	}
	Ft_Esd_IdleChecker_Update__Builtin(context);
}

void Ft_Esd_IdleChecker_ESD_Timer_Fired__Signal(void *c)
{
	Ft_Esd_IdleChecker *context = (Ft_Esd_IdleChecker *)c;
	void *owner = context->Owner;
	ft_bool_t if_8 = context->Touch_Area.Touching;
	if (if_8)
	{
	}
	else
	{
		int left_6 = context->IdleTime;
		int right_6 = 1L;
		int value_1 = left_6 + right_6;
		ft_int32_t min_1 = 0L;
		int max_1 = context->TimeLimit;
		ft_int32_t set_increase_1 = Ft_Esd_Int32_ClampedValue(value_1, min_1, max_1);
		context->IdleTime = set_increase_1;
	}
	ft_bool_t copy_status_1 = context->Status;
	context->PreviousStatus = copy_status_1;
	int left_7 = context->IdleTime;
	int right_7 = context->TimeLimit;
	int if_9 = left_7 == right_7;
	if (if_9)
	{
		ft_bool_t set_timeout_status_1 = 1;
		context->Status = set_timeout_status_1;
	}
	else
	{
		ft_bool_t clear_timeout_status_1 = 0;
		context->Status = clear_timeout_status_1;
	}
	ft_bool_t left_8 = context->PreviousStatus;
	ft_bool_t right_8 = 1;
	int if_10 = left_8 == right_8;
	if (if_10)
	{
		ft_bool_t left_9 = context->Status;
		ft_bool_t right_9 = 0;
		int if_11 = left_9 == right_9;
		if (if_11)
		{
			ft_bool_t set_deferred_wakeup_1 = 1;
			context->Deferred_Wakeup = set_deferred_wakeup_1;
		}
		else
		{
		}
	}
	else
	{
		ft_bool_t left_10 = context->Status;
		ft_bool_t right_10 = 1;
		int if_12 = left_10 == right_10;
		if (if_12)
		{
			context->Timeout(owner);
		}
		else
		{
		}
	}
}

int Ft_Esd_IdleChecker_Touch_Area_X__Property(void *c)
{
	Ft_Esd_IdleChecker *context = (Ft_Esd_IdleChecker *)c;
	void *owner = context->Owner;
	return context->X(owner);
}

int Ft_Esd_IdleChecker_Touch_Area_Y__Property(void *c)
{
	Ft_Esd_IdleChecker *context = (Ft_Esd_IdleChecker *)c;
	void *owner = context->Owner;
	return context->Y(owner);
}

int Ft_Esd_IdleChecker_Touch_Area_Width__Property(void *c)
{
	Ft_Esd_IdleChecker *context = (Ft_Esd_IdleChecker *)c;
	void *owner = context->Owner;
	return context->Width(owner);
}

int Ft_Esd_IdleChecker_Touch_Area_Height__Property(void *c)
{
	Ft_Esd_IdleChecker *context = (Ft_Esd_IdleChecker *)c;
	void *owner = context->Owner;
	return context->Height(owner);
}

void Ft_Esd_IdleChecker_Touch_Area_Up__Signal(void *c)
{
	Ft_Esd_IdleChecker *context = (Ft_Esd_IdleChecker *)c;
	void *owner = context->Owner;
	int clear_1 = 0L;
	context->IdleTime = clear_1;
	ft_bool_t if_13 = context->Touch_Area.Touching;
	if (if_13)
	{
	}
	else
	{
		int left_11 = context->IdleTime;
		int right_11 = 1L;
		int value_2 = left_11 + right_11;
		ft_int32_t min_2 = 0L;
		int max_2 = context->TimeLimit;
		ft_int32_t set_increase_2 = Ft_Esd_Int32_ClampedValue(value_2, min_2, max_2);
		context->IdleTime = set_increase_2;
	}
	ft_bool_t copy_status_2 = context->Status;
	context->PreviousStatus = copy_status_2;
	int left_12 = context->IdleTime;
	int right_12 = context->TimeLimit;
	int if_14 = left_12 == right_12;
	if (if_14)
	{
		ft_bool_t set_timeout_status_2 = 1;
		context->Status = set_timeout_status_2;
	}
	else
	{
		ft_bool_t clear_timeout_status_2 = 0;
		context->Status = clear_timeout_status_2;
	}
	ft_bool_t left_13 = context->PreviousStatus;
	ft_bool_t right_13 = 1;
	int if_15 = left_13 == right_13;
	if (if_15)
	{
		ft_bool_t left_14 = context->Status;
		ft_bool_t right_14 = 0;
		int if_16 = left_14 == right_14;
		if (if_16)
		{
			ft_bool_t set_deferred_wakeup_2 = 1;
			context->Deferred_Wakeup = set_deferred_wakeup_2;
		}
		else
		{
		}
	}
	else
	{
		ft_bool_t left_15 = context->Status;
		ft_bool_t right_15 = 1;
		int if_17 = left_15 == right_15;
		if (if_17)
		{
			context->Timeout(owner);
		}
		else
		{
		}
	}
	ft_bool_t if_18 = context->Deferred_Wakeup;
	if (if_18)
	{
		context->WakeUp(owner);
		ft_bool_t clear_deferred_wakeup_1 = 0;
		context->Deferred_Wakeup = clear_deferred_wakeup_1;
	}
	else
	{
	}
}

void Ft_Esd_IdleChecker_Touch_Area_Down__Signal(void *c)
{
	Ft_Esd_IdleChecker *context = (Ft_Esd_IdleChecker *)c;
	void *owner = context->Owner;
	int clear_2 = 0L;
	context->IdleTime = clear_2;
	ft_bool_t if_19 = context->Touch_Area.Touching;
	if (if_19)
	{
	}
	else
	{
		int left_16 = context->IdleTime;
		int right_16 = 1L;
		int value_3 = left_16 + right_16;
		ft_int32_t min_3 = 0L;
		int max_3 = context->TimeLimit;
		ft_int32_t set_increase_3 = Ft_Esd_Int32_ClampedValue(value_3, min_3, max_3);
		context->IdleTime = set_increase_3;
	}
	ft_bool_t copy_status_3 = context->Status;
	context->PreviousStatus = copy_status_3;
	int left_17 = context->IdleTime;
	int right_17 = context->TimeLimit;
	int if_20 = left_17 == right_17;
	if (if_20)
	{
		ft_bool_t set_timeout_status_3 = 1;
		context->Status = set_timeout_status_3;
	}
	else
	{
		ft_bool_t clear_timeout_status_3 = 0;
		context->Status = clear_timeout_status_3;
	}
	ft_bool_t left_18 = context->PreviousStatus;
	ft_bool_t right_18 = 1;
	int if_21 = left_18 == right_18;
	if (if_21)
	{
		ft_bool_t left_19 = context->Status;
		ft_bool_t right_19 = 0;
		int if_22 = left_19 == right_19;
		if (if_22)
		{
			ft_bool_t set_deferred_wakeup_3 = 1;
			context->Deferred_Wakeup = set_deferred_wakeup_3;
		}
		else
		{
		}
	}
	else
	{
		ft_bool_t left_20 = context->Status;
		ft_bool_t right_20 = 1;
		int if_23 = left_20 == right_20;
		if (if_23)
		{
			context->Timeout(owner);
		}
		else
		{
		}
	}
}

#ifdef ESD_SIMULATION
#include <stdlib.h>

typedef struct
{
	Ft_Esd_IdleChecker Instance;
	int X;
	int Y;
	int Width;
	int Height;
	int Count;
	int Interval;
} Ft_Esd_IdleChecker__ESD;

int Ft_Esd_IdleChecker__Get_X__ESD(void *context) { return ((Ft_Esd_IdleChecker__ESD *)context)->X; }
void Ft_Esd_IdleChecker__Set_X__ESD(void *context, int value) { ((Ft_Esd_IdleChecker__ESD *)context)->X = value; }
int Ft_Esd_IdleChecker__Get_Y__ESD(void *context) { return ((Ft_Esd_IdleChecker__ESD *)context)->Y; }
void Ft_Esd_IdleChecker__Set_Y__ESD(void *context, int value) { ((Ft_Esd_IdleChecker__ESD *)context)->Y = value; }
int Ft_Esd_IdleChecker__Get_Width__ESD(void *context) { return ((Ft_Esd_IdleChecker__ESD *)context)->Width; }
void Ft_Esd_IdleChecker__Set_Width__ESD(void *context, int value) { ((Ft_Esd_IdleChecker__ESD *)context)->Width = value; }
int Ft_Esd_IdleChecker__Get_Height__ESD(void *context) { return ((Ft_Esd_IdleChecker__ESD *)context)->Height; }
void Ft_Esd_IdleChecker__Set_Height__ESD(void *context, int value) { ((Ft_Esd_IdleChecker__ESD *)context)->Height = value; }
int Ft_Esd_IdleChecker__Get_Count__ESD(void *context) { return ((Ft_Esd_IdleChecker__ESD *)context)->Count; }
void Ft_Esd_IdleChecker__Set_Count__ESD(void *context, int value) { ((Ft_Esd_IdleChecker__ESD *)context)->Count = value; }
int Ft_Esd_IdleChecker__Get_Interval__ESD(void *context) { return ((Ft_Esd_IdleChecker__ESD *)context)->Interval; }
void Ft_Esd_IdleChecker__Set_Interval__ESD(void *context, int value) { ((Ft_Esd_IdleChecker__ESD *)context)->Interval = value; }

void *Ft_Esd_IdleChecker__Create__ESD()
{
	Ft_Esd_IdleChecker__ESD *context = (Ft_Esd_IdleChecker__ESD *)malloc(sizeof(Ft_Esd_IdleChecker__ESD));
	Ft_Esd_IdleChecker__Initializer(&context->Instance);
	context->Instance.Owner = context;
	context->X = 0L;
	context->Instance.X = Ft_Esd_IdleChecker__Get_X__ESD;
	context->Y = 0L;
	context->Instance.Y = Ft_Esd_IdleChecker__Get_Y__ESD;
	context->Width = 800L;
	context->Instance.Width = Ft_Esd_IdleChecker__Get_Width__ESD;
	context->Height = 800L;
	context->Instance.Height = Ft_Esd_IdleChecker__Get_Height__ESD;
	context->Count = 30L;
	context->Instance.Count = Ft_Esd_IdleChecker__Get_Count__ESD;
	context->Interval = 1000L;
	context->Instance.Interval = Ft_Esd_IdleChecker__Get_Interval__ESD;
	return context;
}

void Ft_Esd_IdleChecker__Destroy__ESD(void *context)
{
	free(context);
}

void Ft_Esd_IdleChecker__Set_PreviousStatus__ESD(void *context, ft_bool_t value) { ((Ft_Esd_IdleChecker__ESD *)context)->Instance.PreviousStatus = value; }
void Ft_Esd_IdleChecker__Set_IdleTime__ESD(void *context, int value) { ((Ft_Esd_IdleChecker__ESD *)context)->Instance.IdleTime = value; }
void Ft_Esd_IdleChecker__Set_Status__ESD(void *context, ft_bool_t value) { ((Ft_Esd_IdleChecker__ESD *)context)->Instance.Status = value; }
void Ft_Esd_IdleChecker__Set_TimeLimit__ESD(void *context, int value) { ((Ft_Esd_IdleChecker__ESD *)context)->Instance.TimeLimit = value; }
void Ft_Esd_IdleChecker__Set_Deferred_Wakeup__ESD(void *context, ft_bool_t value) { ((Ft_Esd_IdleChecker__ESD *)context)->Instance.Deferred_Wakeup = value; }

#endif /* ESD_SIMULATION */

/* end of file */
